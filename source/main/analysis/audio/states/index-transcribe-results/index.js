// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
const PATH = require('path');
const {
  AnalysisTypes,
  AnalysisError,
  NodeWebVtt,
  CommonUtils,
} = require('core-lib');
const BaseStateIndexer = require('../shared/baseStateIndexer');

const SUB_CATEGORY = AnalysisTypes.Transcribe;
class StateIndexTranscribeResults extends BaseStateIndexer {
  constructor(stateData) {
    super(stateData, SUB_CATEGORY);
    this.$sanitizedVtt = undefined;
  }

  get [Symbol.toStringTag]() {
    return 'StateIndexTranscribeResults';
  }

  get dataKey() {
    return this.stateData.data[SUB_CATEGORY].vtt;
  }

  get sanitizedVtt() {
    return this.$sanitizedVtt;
  }

  set sanitizedVtt(val) {
    this.$sanitizedVtt = val;
  }

  async process() {
    const response = await super.process();
    await this.workaroundInvalidVttTimestamps();
    return response;
  }

  async workaroundInvalidVttTimestamps() {
    /* workaround invalid timestamp WebVTT file generated by Amazon Transcribe */
    if (this.sanitizedVtt !== undefined) {
      const bucket = this.stateData.input.destination.bucket;
      const key = this.dataKey;
      const parsed = PATH.parse(key);
      await CommonUtils.uploadFile(bucket, parsed.dir, parsed.base, this.sanitizedVtt)
        .catch(() =>
          undefined);
    }
  }

  parseDataset(datasets) {
    if (!datasets) {
      return undefined;
    }
    const vtt = this.parseWebVtt(datasets);
    if (vtt.cues.length === 0) {
      return undefined;
    }
    const phrases = [];
    while (vtt.cues.length) {
      const cue = vtt.cues.shift();
      while (cue.text.length) {
        const name = cue.text.shift();
        phrases.push({
          name,
          timecodes: [
            {
              begin: cue.begin,
              end: cue.end,
            },
          ],
        });
      }
    }
    return phrases;
  }

  parseWebVtt(vtt) {
    const parsed = NodeWebVtt.parse(vtt, {
      meta: true,
      strict: false,
    });
    if (!parsed.valid) {
      throw new AnalysisError('failed to parse vtt');
    }

    /* fixing the webvtt */
    const cues = [];
    cues.push(parsed.cues.shift());
    while (parsed.cues.length) {
      const cue = parsed.cues.shift();
      if (cue.start > 0 && cue.end > 0 && (cue.end - cue.start) > 0) {
        cues.push(cue);
      }
    }
    if (cues.length !== parsed.cues.length) {
      parsed.cues = cues.map((cue, idx) => ({
        ...cue,
        identifier: String(idx),
      }));
      this.sanitizedVtt = NodeWebVtt.compile(parsed);
    }

    parsed.cues = parsed.cues.map((cue) => {
      const lines = cue.text.split('\n').map((x) => {
        const matched = x.match(/^--\s(.*)/);
        return (matched)
          ? matched[1].trim()
          : x.trim();
      }).filter((x) =>
        x && x.length > 0);
      return (lines.length > 0)
        ? {
          id: Number(cue.identifier),
          begin: Math.round(cue.start * 1000),
          end: Math.round(cue.end * 1000),
          text: lines,
        }
        : undefined;
    }).filter((x) =>
      x !== undefined);
    return parsed;
  }
}

module.exports = StateIndexTranscribeResults;
